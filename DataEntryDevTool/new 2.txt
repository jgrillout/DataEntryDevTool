// Version: 6.28.24.09.24
// File: StringInput.cpp
#pragma once
#include "DataEntry.h"

bool DataEntry::stringInput(DataEntry& dataEntry, std::ofstream& debugFile) {
    /*Note: parameter names are different than the declarations so they match
    the names of code I borrowed from a business BASIC program GENINPUT.PUB*/
    std::string X$ = "";
    std::string EDIT$ = "";
    std::string Action = "";
    std::string before = "";
    std::string after = "";
    WINDOW* saveWin = dataEntry.getWin();
    size_t saveLen = dataEntry.getLength();
    int saveRow = dataEntry.getRow();
    int saveColumn = dataEntry.getFieldColumn();
    int rows = saveWin->_maxy; 
    int cols = saveWin->_maxx;
    int POS = 0;
    int SAVEPOS = 0; //size_t
    bool MASKED = false;
    bool END = false;
    bool INSERT = false;
    int inputSize = 0; //size_t
    int index = 0; //size_t

    // Retrieve existing value (if any)
    EDIT$ = dataEntry.getFieldValue();
    inputSize = EDIT$.size(); // Size of the initial value
    if (inputSize < saveLen) {
        EDIT$.append(saveLen - inputSize, ' ');
    }
    POS = EDIT$.find_last_not_of(' ') + 1;
    SAVEPOS = POS;   
    // Enable keypad mode to capture function keys
    keypad(saveWin, TRUE);
    int c = 0;
    bool quit = false;    

    mvwprintw(saveWin, saveRow, saveColumn, EDIT$.c_str());

    // Capture user input until Enter key is pressed
    while (!quit) {
        wattron(saveWin, COLOR_PAIR(2));
        mvwprintw(saveWin, saveRow, saveColumn, EDIT$.c_str());
        wrefresh(saveWin);
        c = wgetch(saveWin);
        std::string action = keyname(c);

#pragma region // Start of switch
        switch (c) {
        case PADENTER:
        case 10:  // Enter key    
            Action = "KEY_ENTER";
            goto exitField;              
        case KEY_F(1):
            Action = "KEY_F(1)";
            quit = true;
            break;
        case KEY_F(2):
            Action = "KEY_F(2)";
            quit = true;
            break;
        case KEY_F(3):
            Action = "KEY_F(3)";
            quit = true;
            break;
        case KEY_F(4):
            Action = "KEY_F(4)";
            quit = true;
            break;
        case KEY_F(5):
            Action = "KEY_F(5)";
            quit = true;
            break;
        case KEY_F(6):
            Action = "KEY_F(6)";
            quit = true;
            break;
        case KEY_F(7):
            Action = "KEY_F(7)";
            wrefresh(saveWin);
            quit = true;
            break;
        case KEY_F(8):
            Action = "KEY_F(8)";
            wrefresh(saveWin);
            quit = true;
            break;
        case KEY_F(9):
            Action = "KEY_F(9)";
            wrefresh(saveWin);
            quit = true;
            break;
        case KEY_F(10):
            Action = "KEY_F(10)";
            wrefresh(saveWin);
            quit = true;
            break;
        case KEY_UP:
            Action = "KEY_UP";
            wrefresh(saveWin);
            quit = true;
            break;
        case KEY_LEFT:
            if (POS == 0) {
                beep();
            } else {
                --POS;
            }
            break;
        case KEY_RIGHT:            
            if (POS + 1 >= saveLen) {
                beep();
                POS = saveLen;
            } else {
                POS++;
            }
            break;
        case KEY_END:            
            index = EDIT$.find_last_not_of(' ');
            POS = index + 1;
            break;
        case KEY_HOME:          
            POS = 0; 
            break;
        case KEY_DC:  // Delete    
            before = EDIT$.substr(0, POS - 1);
            after = EDIT$.substr(POS + 1);
            EDIT$ = before + " " + after;
            break;       
        case PAD0:  // INSERT  
        case 331:  // INSERT
            INSERT = !INSERT;
            if (INSERT) {
                wattron(saveWin, COLOR_PAIR(2));
                mvwprintw(saveWin, rows - 2, cols - 8, "Insert");
            } else {
                wattron(saveWin, COLOR_PAIR(3));
                mvwprintw(saveWin, rows - 2, cols - 8, "       ");
                wattron(saveWin, COLOR_PAIR(2));
            }
            break;
        case 8:  // Handle backspace
            if (POS == 0) {
                beep();
            } else {
                SAVEPOS = POS;
                --POS;
            }
            if (SAVEPOS != POS) {
                if (POS != saveLen) {
                    std::string before = EDIT$.substr(0, POS);
                    std::string after = EDIT$.substr(POS + 1) + " ";
                    EDIT$ = before + after;
                }
            }
            break;

        default:
            if (c >= 0 && c <= 127) {
                if (POS > saveLen) {
                    beep();
                    break;
                }
            } else {
                Action = "KEY_NOT"; // Deal with keys not planned for
                wrefresh(saveWin);
                quit = true;
                break;
            }
            // Check if the character is printable
            if (std::isprint(c)) {
                char character = static_cast<char>(c);
                // For choice field type
                if (dataEntry.getFieldType() == FieldType::Choice) {
                    const std::string& allowed = dataEntry.getAllowedChoices();
                    if (allowed.find(character) == std::string::npos) {
                        beep();
                        break;
                    }
                    mvwprintw(saveWin, saveRow + 1, saveColumn, dataEntry.getChoiceDescriptions().c_str());
                }
                std::string chString(1, character);
                if (INSERT) {
                    if (POS != character) {
                        X$ = EDIT$.substr(POS, 1);
                        before = EDIT$.substr(0, POS);
                        after = EDIT$.substr(POS);
                        EDIT$ = before + chString + after;
                        EDIT$ = EDIT$.substr(0, character);
                    } else {
                        beep();
                    }
                } else {
                    EDIT$.replace(POS, 1, chString);
                }
                POS++;
                if (POS > saveLen) {
                    END = true;
                    POS = saveLen;
                }
                wrefresh(saveWin);
            }
        }
#pragma endregion // End of switch
    }

    // If quit is true, handle special key presses
    if (quit) {
        dataEntry.setFieldValue(EDIT$);    
        dataEntry.setInputKeyPressed(Action);             
        return true;
    }

exitField:
    dataEntry.setFieldValue(EDIT$);
    dataEntry.setInputKeyPressed(Action);
    return false; // Indicates we have a string and no function key was pressed
}
